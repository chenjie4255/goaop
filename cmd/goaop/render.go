package main

import (
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
)

var renderTemplate = template.Must(template.New("render").Parse(`// This file is generated by goaoop, DO NOT EDIT IT.
// see (github.com/chenjie4255/goaop) 
package {{.Package}}
import (
	"github.com/chenjie4255/goaop"
	{{range .ImportPaths}}
{{.Name}} {{.Path}}{{end}}
)

type measure{{.InterfaceName}} struct {
	{{.InterfaceName}}
	builder goaop.PointcutBuilder
}

func NewMeasure{{.InterfaceName}}(o {{.InterfaceName}}, builder goaop.PointcutBuilder) {{.InterfaceName}} {
	return &measure{{.InterfaceName}}{o, builder}
}

{{range .Methods}}
func (m *measure{{$.InterfaceName}}) {{.Raw}} {
	pointcut := m.builder.Build("{{.Name}}")
	if pointcut == nil {
		{{if eq .ResultCount 0}}m.{{.Name}}({{.GetParams}}){{else}}return m.{{.Name}}({{.GetParams}}){{end}}
	} else {
		pointcut.OnEntry()
		{{if eq .ResultCount 0}}m.{{.Name}}({{.GetParams}})
		pointcut.OnReturn(nil)
		{{else}} {{.GetResults}} := m.{{.Name}}({{.GetParams}})
		{{if eq .ResultErrorIndex -1}}
		pointcut.OnReturn(nil)
		{{else}}pointcut.OnReturn(err){{end}}
		return {{.GetResults}} {{end}}
	}
}
{{end}}


`))

type renderParam struct {
	Name    string
	Varargs bool // 是否可变参数...
}

type renderMethod struct {
	Raw              string
	Name             string
	Params           []renderParam
	ResultCount      int
	ResultErrorIndex int
}

func (m renderMethod) GetParams() string {
	params := []string{}
	for _, p := range m.Params {
		if p.Varargs {
			params = append(params, p.Name+"...")
		} else {
			params = append(params, p.Name)
		}
	}

	return strings.Join(params, " ,")
}

func (m renderMethod) GetResults() string {
	results := []string{}
	for i := 0; i < m.ResultCount; i++ {
		if i == m.ResultErrorIndex {
			results = append(results, "err")
		} else {
			results = append(results, fmt.Sprintf("r%d", i))
		}
	}

	return strings.Join(results, ",")
}

type renderData struct {
	Package       string
	InterfaceName string
	ImportPaths   []importObj
	Methods       []renderMethod
}

func (d renderData) debugPrint() {
	fmt.Printf("package:%s\n", d.Package)
	fmt.Printf("Interface:%s\n", d.InterfaceName)
	fmt.Print("Imports:\n")
	for _, path := range d.ImportPaths {
		fmt.Println(path.Name, path.Path)
	}

	fmt.Println("Methods:")
	for _, method := range d.Methods {
		params := []string{}
		for _, p := range method.Params {
			if p.Varargs {
				params = append(params, p.Name+"...")
			} else {
				params = append(params, p.Name)
			}
		}
		fmt.Printf("%s\n\t%s\n\t%s\n", method.Name, method.Raw, strings.Join(params, " "))
		fmt.Printf("\t%s\n", method.GetResults())
	}

}

func (d *renderData) addImportPath(name, path string) {
	for _, p := range d.ImportPaths {
		if p.Path == path {
			return
		}
	}

	d.ImportPaths = append(d.ImportPaths, importObj{name, path})
}

func render(outputPath string, data renderData) {
	output, err := os.OpenFile(outputPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		log.Fatalf("create/open output file(%s) fail: %s", outputPath, err)
		return
	}
	defer output.Close()
	renderTemplate.Execute(output, data)
}
